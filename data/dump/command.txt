pg_restore -h localhost -U postgres -F t -d book_library_db data/dump/book_library_db.tar
cat data/dump/book_library_db.sql | psql -h localhost -U postgres book_library_db
sudo service postgresql restart
pg_dump -h localhost -U postgres -F t -f data/dump/book_library_db.tar book_library_db
pg_dump -h localhost -U postgres -F p -f data/dump/book_library_db.sql book_library_db
172.17.0.1
192.168.220.185

//Снятие дампа в сыром виде (-F p) без данных(-s) и  удаление структуры вначале(-с)
pg_dump -h localhost -U postgres -F p -f data/dump/book_library_db.sql -s -c book_library_db
//Снятие дампа(только инсерты)
pg_dump -h localhost -U postgres -F p -f data/dump/book_library_db_insert.sql -a --column-inserts book_library_db



//Добавление автоинкримента
ALTER TABLE countries alter COLUMN id add generated ALWAYS AS identity
//Удаление автоинкремента
alter table countries alter COLUMN id set GENERATED BY DEFAULT

//Создание таблицы стран с первичным ключом id
CREATE TABLE countries
(
    id int not null constraint countries_pk PRIMARY KEY,
    name varchar(2) not null,
    description varchar(255)
)

//Добавление сиквинсе к колонке таблицы(автоинкремент)
alter table countries alter column id set default nextval('countries_sq')

//Создание сиквинса
create sequence countries_sq

//Устанавливаем для сиквенса начальное айди
select setval('users_id_seq',max(id) + 1) from users




//Пример запроса с джоином таблицы самой к себе
select
    t.title as text_document_title,
    a.name as author_name,
    a.surname as author_surname,
       string_agg(td.title, ','),
    count(td.id)
from text_documents as t
         JOIN authors as a ON t.author_id = a.id
         JOIN text_documents td on td.author_id = a.id

group by t.id, a.name, a.surname


//Пример запроса
select t.id        as id,
       t.title     as title,
       t.year      as year,
       t.status    as status,
       t.type      as type,
       t.number    as number,
       a.name      as author_name,
       a.surname   as author_surname,
       a.birthday  as author_birthday,
       a.country   as author_country,
       pp.price    as purchase_price_price,
       pp.date     as purchase_price_date,
       pp.currency as purchase_price_currency
from text_documents as t
         LEFT JOIN authors a on a.id = t.author_id
         LEFT JOIN purchase_price pp on t.id = pp.text_document_id




//Создание индексов
create index  if not exists text_documents_type_idx on text_documents(type);
create index  if not exists text_document_to_author_text_document_id_idx on text_document_to_author(text_document_id);







alter table text_documents drop constraint text_documents_text_document_status_id_fk;

alter table text_documents alter column status_id drop not null;

alter table text_documents
    add constraint text_documents_text_document_status_id_fk
        foreign key (status_id) references text_document_status(id)
            on update cascade on delete SET NULL


alter table authors
    add constraint authors_country_id_fk
        foreign key (country_id) references country (id)
            on update cascade on delete restrict;


alter table text_documents
    add constraint text_documents_text_document_status_id_fk
        foreign key (status_id) references text_document_status(id)
            on update cascade on delete restrict;

alter table purchase_price
    add constraint purchase_price_text_documents_id_fk
        foreign key (text_document_id) references text_documents(id)
            on update cascade on delete cascade;


alter table text_document_to_author
    add constraint text_document_to_author_text_documents_id_fk
        foreign key (text_document_id) references text_documents (id)
            on update cascade on delete cascade;

alter table text_document_to_author
    add constraint text_document_to_author_authors_id_fk
        foreign key (author_id) references authors (id)
            on update cascade on delete restrict;

alter table purchase_price
    add constraint purchase_price_currency_id_fk
        foreign key (currency_id) references currency (id)
            on update cascade on delete restrict;









insert into text_document_books (id, isbn)
(
 select t.id, null
 from text_documents as t
 where type = 'book'
);


insert into text_document_magazines (id, number)
    (
        select t.id, t.number
        from text_documents as t
        where type = 'magazine'
    );



db.local.di.config












<?xml version="1.0" encoding="UTF-8" ?>
<container xmlns="http://symfony.com/schema/dic/services"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:e_db="https://effective-group.ru/schema/dic/eff_tech_infrastructure_db"
           xsi:schemaLocation="http://symfony.com/schema/dic/services
           http://symfony.com/schema/dic/services/services-1.0.xsd">
    <e_db:config>
        <e_db:connect>
            <e_db:dbType>pgsql</e_db:dbType>
            <e_db:user>postgres</e_db:user>
            <e_db:password>Qwerty12</e_db:password>
            <e_db:dbName>book_library_db</e_db:dbName>
            <e_db:host>localhost</e_db:host>
            <e_db:port>5432</e_db:port>
            <e_db:option name="a1">1</e_db:option>
            <e_db:option name="a2">2</e_db:option>
            <e_db:option name="a3">3</e_db:option>
        </e_db:connect>
    </e_db:config>
</container>









.\vendor\bin\doctrine orm:convert-mapping --from-database --namespace='App\Entity' xml  ./src/config/xml

.\vendor\bin\doctrine orm:convert-mapping --from-database --namespace='App\Entity' annotation ./src/Entity









create table if not exists text_document_status
(
    id int primary key generated by default as identity,
    name varchar(50) not null
);


insert into text_document_status (name) (
    select distinct status from text_documents
);



alter table text_documents add column if not exists status_id integer null;


update text_documents as t
set status_id = s.id
from text_document_status as s
where t.status = s.name;


alter table text_documents drop column status;


select ts.name, count(*)
from text_document_status ts
join text_documents td on ts.id = td.status_id
group by ts.name;

update text_documents as t
set status_id = tds.id
from text_document_status as s
join text_document_status as tds on s.name = 'inStock'
where t.status_id = s.id and s.name = 'archive';


create table country
(
    id int primary key generated BY DEFAULT as identity,
    code2 varchar(2) not null,
    code3 varchar(3) null,
    code varchar(3) null,
    name varchar(100) null
);


insert into country (code2) (
    SELECT DISTINCT country from authors
)